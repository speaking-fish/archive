==============================================================================

  Содержание
  ----------------------------------------------------------------------------

  Схема работы

  Типы серверных и клиентских объектов
    Понятие набора данных.
      Колонки
      Типы данных
      Вычисления на клиенте
        Типы на клиенте
        Визуальные элементы управления

      Вычисления на сервере
        Подстановки в наборе данных

    Понятие источника данных
      Параметры
      Подстановки

  Отчет
    Параметры отчета
    Типы данных и визуальные элементы
    Передача результатов источников другим источникам в качестве параметров
    Порядок вычислений

  Типы источников
    Внешние источники
      Создание источника
      SQL-источник
        Типы параметров

      ServerProvider-источник
        Типы параметров

      CustomQueryProvider-источник
        Типы параметров

    Специальные источники
      Union-источник
      Grouping-источник
      Системный источник

  Компоновка отчета
    Шаблоны и подстановки
    Маркеры, обрабатываемые генератором отчетов
    Маркеры "define"
    Маркеры форматирования шаблонов
    Типы данных Excel
    Вычисляемые выражения Excel
      Описания контекстов

  Типы объектов компоновки
    Набор данных
      Контексты набора данных
      Шаблоны набора данных

    Таблица
      Контексты таблицы
      Шаблоны таблиц
      Порядок расчета таблиц

  Работа с Excel
    Формулы Excel
    Конкатенация строк
    Выполнение join (lookup)
    Использование вычисляемых колонок сортировки
    Использование вычисляемых колонок группировки
    Наращиваемые итоги
    Форматирование кодов
    Форматирование дебита/кредита

  Стыковка с системой
    Вызов отчета из меню
    Документы
      Печать документов
      Печать списка документов

  Приложение
    Зарезервированные имена
    Используемые в REPORTER.XLA библиотеки
    Таблица соответствия русских названий формул английским

==============================================================================

  Схема работы
  ----------------------------------------------------------------------------

  Генератор отчета состоит из трех частей, расположенных в разных частях
    системы:
    - Сервер приложений
    - Клиентская программа
    - Excel

  Результатом работы генератора отчета является созданная в Excel книга.

  Процесс происходит следующим образом:

    Пользователь     Клиентская       Сервер           Excel
                     программа        приложений       .
    .                .                .                .
    * Вызов          .                .                .
    * исполнителя    .                .                .
    * отчетов        .                .                .
    *--------------->*                .                .
    *                * Запрос         .                .
    *                * описания       .                .
    *                * формы          .                .
    *                *--------------->*                .
    *                .                * Формирование   .
    *                .                * описания       .
    *                .                * формы          .
    *                *<---------------*                .
    *                * Формирование   .                .
    *                * формы          .                .
    *<---------------*                .                .
    .                .                .                .
    * Ввод           .                .                .
    * параметров     .                .                .
    * формы          .                .                .
    *                .                .                .
    .                .                .                .
    * Выполнение     .                .                .
    * отчета         .                .                .
    * с заданными    .                .                .
    * параметрами    .                .                .
    *--------------->*                .                .
    *                * Передача       .                .
    *                * параметров     .                .
    *                *--------------->*                .
    *                .                * Выполнение     .
    *                .                * отчета         .
    *                *<---------------*                .
    *                *                .                .
    *                * Передача       .                .
    *                * результата     .                .
    *                *-------------------------------->*
    *                .                .                * Формирование
    *                .                .                * книги
    *                .                .                * Excel
    *<-------------------------------------------------*
    .                .                .                .



==============================================================================

  Типы серверных и клиентских объектов
  ----------------------------------------------------------------------------

==============================================================================

  Понятие набора данных.
  ----------------------------------------------------------------------------

  "Набор данных" представляет собой именованый набор записей (строк)
  одного типа.

  Набор данных однозначно определяется внутри группы наборов данных по
  имени.

  Елемент записи называется колонкой (полем).

  Тип записи описывается в определении набора данных.

  В XML это выглядит так:

    <dataset NAME="Peoples">
      <columns>
        <column NAME="name" TYPE="string" />
        <column NAME="age"  TYPE="integer"/>
      </columns>
      <source>
        <row name="Иванов"   age="30"/>
        <row name="Smirnoff" age="20"/>
        <row name="Потапов"  age="40"/>
      </source>
    </dataset>

  Все данные в системе представляются в виде наборов данных.


==============================================================================

  Колонки
  ----------------------------------------------------------------------------

  Колонка набора данных однозначно определяется внутри набора данных по
  имени и порядковому номеру.

  Колонка данных имеет тип.

  Дополнительно у колонки может быть необязательный заголовок (CAPTION).
  
  Если название колонки не может быть именем аттрибута, аттрибут будет
  называться "_COLUMN_" + (порядковый_номер_колонки + 1).

  В этом случае у колонки определяется поле ATTRNAME с этим названием.

  Такое название колонка получает автоматически, при неудаче
  использования ее имени в качестве аттрибута.

  Например:

  <dataset NAME="Peoples">
    <columns>
      <column NAME="Ф.И.О." TYPE="string"  ATTRNAME="_COLUMN_1"/>
      <column NAME="age"    TYPE="integer"                     />
    </columns>
    <source>
      <row _COLUMN_1="Иванов"   age="30"/>
      <row _COLUMN_1="Smirnoff" age="20"/>
      <row _COLUMN_1="Потапов"  age="40"/>
    </source>
  </dataset>


==============================================================================

  Типы данных
  ----------------------------------------------------------------------------

  Тип            Тип поля  Формат     тип Java    Стандартное
                           Excel                  название

  строковый      string    текстовый  String      String
  целочисленный  integer   общий      BigDecimal  Numeric
  денежный       currency  общий      BigDecimal  Numeric
  дата           datetime  дата       Date        Datetime

  Прочие типы считаются строковыми.

  В XML значение null любого типа представляется в виде пустой строки.

  В Excel значение null любого типа представляется в виде строки из одного
  пробела.


==============================================================================

  Вычисления на клиенте
  ----------------------------------------------------------------------------

  Определение формул

    Формула начинается с символа "=".
    Прочие значения считаются строковым значением данного типа.

    Например:

      Для поля типа String его значение можно указать:
        либо значением: значение поля
        либо формулой : ="значение поля"
        оба варианта будут означать одно и то же

      Для поля типа Numeric его значение можно указать:
        либо значением: 125
        либо формулой : =Numeric.parse("125")
        оба варианта будут означать одно и то же

      Для поля типа Boolean его значение можно указать:
        либо значением: true
        либо формулой : =Boolean.true
        оба варианта будут означать одно и то же


    Основной тип - String.
    Только тип String поддерживается сейчас парсером.
    Остальные типы данных парсятся из строковых значений.


    Формат вызова нестатической функции без параметров:

      <Выражение> <.> <имя_нестатической_функции>

    Формат вызова нестатической функции c параметрами:

      <Выражение>
        <.> <имя_нестатической_функции>
          <(> <Выражение> { <,> <Выражение> } <)>

    Формат вызова статической функции без параметров:

      <Тип> <.> <имя_статической_функции>

    Формат вызова статической функции с параметрами:

      <Тип> <.> <имя_статической_функции>
        <(> <Выражение> { <,> <Выражение> } <)>


    Общий формат выражения:

      Выражение::=
        "строка" |

        <Тип> <.> <имя_статической_функции>
          [ <(> <Выражение> { <,> <Выражение> } <)> ] |

        <Выражение> <.> <имя_нестатической_функции>
          [ <(> <Выражение> { <,> <Выражение> } <)> ] |

        <имя_элемента> { <.> <имя_элемента> } <.> <имя_поля_элемента>


    Пример:

      =if(  param1.value.lt(Numeric.parse("2"))
        .or(
               param1.value.gt(param2.value)
          .and(param1.value.lt(param3.value))
          )
        .not,
        "Invalid value", ""
        )

==============================================================================

  Типы на клиенте
  ----------------------------------------------------------------------------

  String
  ------

    static String parse(String src)

      строка создается указанием строки в кавычках: "значение строки"
      не имеет смысла взывать функцию String.parse("значение строки")

    static String if(Boolean choice, String a, String b)

      выполняет и возвращает выражение a, если choice = true или b, если
      choice = false

    Numeric length

      возвращает длину строки

    String concat(String dest)
      алиас: add

      объединяет строку со строкой dest

    Boolean isEqual(String dest)
      алиас: eq

      возвращает true, если строка равна dest

    Boolean isLess(String dest)
    алиас: lt
      
      возвращает true, если строка меньше dest

    Boolean isGreate(String dest)
      алиас: gt

      возвращает true, если строка больше dest

    Boolean isLessOrEqual(String dest)
      алиас: le

      возвращает true, если строка меньше или равна  dest
      эквивалентно self.lt(dest).or(self.eq(dest))

    Boolean isGreateOrEqual(String dest)
      алиас: ge

      возвращает true, если строка больше или равна dest
      эквивалентно self.gt(dest).or(self.eq(dest))

    Boolean isEmpty

      возвращает true, если строка пустая
      эквивалентно self.length.eq(Numeric.parse("0"))

    String toUpper

      возвращает строку в верхнем регистре

    String toLower

      возвращает строку в нижнем регистре

  Boolean
  -------

    static Boolean parse(String src)

      возвращает true если src = "true", false, если src="false"
      или false в других случаях

    static Boolean parseDef(String src, Boolean default)

      возвращает true если src = "true", false, если src="false"
      или default в других случаях

    static Boolean true

      возвращает true

    static Boolean false

      возвращает false

    Boolean and(Boolean dest)

      логическое произведение (по короткой схеме)

    Boolean or(Boolean dest)

      логическая сумма  (по короткой схеме)

    Boolean xor(Boolean dest)

      логическое неравенство
      эквивалентно self.eq(dest).not

    Boolean not

      логическое отрицание

    Boolean isEqual(Boolean dest)
      алиас: eq

      логическое равенство

    String toString

      возвращает "true", если значение = true или "false" в противном случае
      эквивалентно String.if(self, "true", "false")

  Numeric
  -------

    static Numeric parse(String src)

      возвращает src, преобразованную в число, если это возможно
      или 0, если это невозможно

    static Numeric parseDef(String src, Numeric default)

      возвращает src, преобразованную в число, если это возможно
      или default, если это невозможно

    static Numeric if(Boolean choice, Numeric a, Numeric b)

      выполняет и возвращает выражение a, если choice = true или b, если
      choice = false

    String toString

      возвращает число, преобразованное в строку

    Boolean isEqual(Numeric dest)
      алиас: eq

      возвращает true, если число равно dest

    Boolean isLess(Numeric dest)
      алиас: lt

      возвращает true, если число меньше dest

    Boolean isGreate(Numeric dest)
      алиас: gt

      возвращает true, если число больше dest

    Boolean isLessOrEqual(Numeric dest)
      алиас: le

      возвращает true, если число меньше или равно dest

    Boolean isGreateOrEqual(Numeric dest)
      алиас: ge

      возвращает true, если число больше или равно dest

    Numeric sum(Numeric dest)
      алиас: add

      возвращает сумму числа с dest

    Numeric sub(Numeric dest)

      возвращает разность числа с dest

    Numeric mul(Numeric dest)

      возвращает произведение числа на dest

    Numeric div(Numeric dest)

      возвращает результат деления числа на dest

    Numeric neg

      возвращает число с противоположным знаком, равное ему по модулю

    Numeric sign

      возвращает -1 если число < 0, 0, если число = 0 и 1, если число > 0

    Numeric abs

      возвращает модуль числа (абсолютное значение)

    Numeric frac

      возвращает дробную часть числа

    Numeric int

      возвращает целую часть числа

    Numeric round

      округляет число

    Numeric max(Numeric dest)

      возвращает максимальное число

    Numeric min(Numeric dest)

      возвращает минимальное число

  Datetime
  --------

    static Datetime parse(String src)

      возвращает src, преобразованную в число, если это возможно
      или текущую дату, если это невозможно

    static Datetime parseDef(String src, Datetime default)
      возвращает src, преобразованную в число, если это возможно
      или default, если это невозможно

    static Datetime if(Boolean choice, Datetime a, Datetime b)

      выполняет и возвращает выражение a, если choice = true или b, если
      choice = false

    String toString

      возвращает дату, преобразованное в строку

    Boolean isEqual(Datetime)
      алиас: eq

      возвращает true, если дата равна dest

    Boolean isLess(Datetime)
      алиас: lt

      возвращает true, если дата меньше dest

    Boolean isGreate(Datetime)
      алиас: gt

      возвращает true, если дата больше dest

    Boolean isLessOrEqual(Datetime)
      алиас: le

      возвращает true, если дата меньше и равна dest

    Boolean isGreateOrEqual(Datetime)
      алиас: ge

      возвращает true, если дата больше и равна dest

    max(Datetime dest)

      возвращает максимальную дату

    min(Datetime dest)

      возвращает минимальную дату

    Datetime beginMonth
      алиас: beginmonth

      возвращает дату начала месяца

    Datetime beginWeek
      алиас: beginweek

      возвращает дату начала недели

    Datetime beginYear
      алиас: beginyear

      возвращает дату начала года

    Datetime endMonth
      алиас: endmonth

      возвращает дату конца месяца
      эквивалентно nextMonth.prevDay

    Datetime endWeek
      алиас: endweek

      возвращает дату конца недели
      эквивалентно nextWeekBegin.prevDay

    Datetime endYear
      алиас: endyear

      возвращает дату конца года
      эквивалентно nextYearBegin.prevDay

    Datetime nextDay
      алиас: nextday

      возвращает следующий день

    Datetime nextMonthBegin
      алиас: nextmonthbegin

      возвращает дату начала следующего месяца
      эквивалентно endMonth.nextDay

    Datetime nextWeekBegin
      алиас: nextweekbegin

      возвращает дату начала следующей недели
      эквивалентно endWeek.nextDay

    Datetime nextYearBegin
      алиас: nextyearbegin

      возвращает дату начала следующего года
      эквивалентно endYear.nextDay

    Datetime prevDay
      алиас: prevday

      возвращает предыдущий день

    Datetime prevMonthBegin
      алиас: prevmonthbegin

      возвращает дату начала предыдущего месяца

    Datetime prevWeekBegin
      алиас: prevweekbegin

      возвращает дату начала предыдущей недели

    Datetime prevYearBegin
      алиас: prevyearbegin

      возвращает дату начала предыдущего года

    Numeric year

      возвращает год

    Numeric month

      возвращает месяц

    Numeric day

      возвращает день


  SYSTEM
  ------

    static Datetime WORK_DATE

      возвращает рабочую дату

    static Numeric BUDGET_ID

      возвращает активный бюджет


==============================================================================

  Визуальные элементы управления
  ----------------------------------------------------------------------------

    Поля визуальных элементов

      формула           название
                        поля
                        в вычислениях

      DEFAULT                         <тип_поля>  начальное значение
      CONTROLVALUE      value         <тип_поля>  перекрывает default
      CONTROLCAPTION    caption       String      перекрывает CAPTION 
      CONTROLENABLED    enabled       Boolean     
      CONTROLVISIBLE    visible       Boolean     
      CONTROLREADONLY   readOnly      Boolean
      CONTROLREQUIRED   required      Boolean     перекрывает REQUIRED
      CONTROLREFPARAMS  refParams     String      поэлементно
                                                  перекрывает REFPARAMS
                        isModified    Boolean


      CONTROLVALUE
      ------------

      Вычисляемое значение контрола.

      Тип - тип поля.

      Если не задано вычисляемое значение контрола, контрол ведет себя как
      обычно.

      Если задано вычисляемое значение контрола, то значение контрола будет
      вычисляемым.
      Это можно использовать, например, для промежуточных вычислений (в этом
      случае можно сделать контрол невидимым).
      Если вы хотите использовать вычисляемые в процессе заполнения формы
      дефолтные значения контролов, то для определения того, было ли это поле
      изменено пользователем, надо воспользоваться функцией isModified.

      Например:
        Допустим мы хотим чтобы значение поля C было равно сумме значений поля
        A и B, если значение поля C не было изменено пользователем. Для этого
        у параметра param1 в поле CONTROLVALUE мы вводим формулу:

          =Numeric.if(C.isModified, C.value, A.value.add(B.value))

        
      CONTROLCAPTION
      --------------

      Вычисляемый заголовок контрола.

      Тип - строковый.

      Если вычисляемый заголовок контрола не задан, то заголовок контрола
      определяется обычным полем caption.

      Вычисляемый заголовок контрола не используется для обозначения заголовка
      поля в таблице params - для этого используется обычное поле caption.

      Пример:
          ="Параметр1"
           .add(if(param1.value.isEmpty, " должен быть заполнен!", ""))


      CONTROLENABLED
      --------------

      Вычисляемое поле, определяющее возможность редактирования контрола
      и его внешний вид.

      Тип - логический.

      Если формула не определена, то enabled=true.

      При enabled=false контрол не может принимать фокус ввода, не может быть
      изменен пользователем, окрашивается в серый цвет.


      CONTROLVISIBLE
      --------------

      Вычисляемое поле, определяющее видимость контрола.

      Тип - логический.

      Если формула не определена, то visible=true.


      CONTROLREADONLY
      ---------------

      Вычисляемое поле, определяющее возможность редактирования контрола.

      Тип - логический.

      Если формула не определена, то определяется обычным readonly.

      Подобно CONTROLENABLED, но не влияет на внешний вид контрола.


      CONTROLREQUIRED
      ---------------

      Вычисляемое поле, определяющее обязательность заполнения контрола.

      Тип - логический.

      Если формула не определена, то определяется обычным required.


      CONTROLREFPARAMS
      ----------------

      Вычисляемое поле, определяющее параметры ссылки.

      Тип - строковый.

      Параметры ссылки определяются полем refparams, но вычисляемое поле
      параметров неполностью, но поэлементно перекрывает их.

      Строка параметров представляет собой строки вида
        имя_параметра=значение_параметра
      или
        имя_параметра="значение параметра"
      разделенные запятой.

      Таким образом вычисляемые параметры перекрывают параметры refparams
      по именам параметров.


      default
      -------

      Поле определяет значение по умолчанию.

      Значение по умолчанию вычисляется один раз, во время инициализации
      контролов.

      Формула, вычисляющая default значение не может ссылаться на значения
      других полей.

      Пример формулы:

        =SYSTEM.WORK_DATE.year


==============================================================================

  Вычисления на сервере
  ----------------------------------------------------------------------------

  Дата
  ----

  Операции на сервере:

  beginyear      возвращает дату начала года для указанной даты
  endyear        возвращает дату конца  года для указанной даты
  prevyearbegin  возвращает дату начала предыдущего года для указанной даты
  nextyearbegin  возвращает дату начала следующего  года для указанной даты
  beginmonth     возвращает дату начала месяца для указанной даты
  endmonth       возвращает дату конца  месяца для указанной даты
  prevmonthbegin возвращает дату начала предыдущего месяца для указанной даты
  nextmonthbegin возвращает дату начала следующего  месяца для указанной даты
  beginweek      возвращает дату начала недели для указанной даты
  endweek        возвращает дату конца  недели для указанной даты
  prevweekbegin  возвращает дату начала предыдущей недели для указанной даты
  nextweekbegin  возвращает дату начала следующей  недели для указанной даты
  nextday        возвращает следующую  дату для указанной даты
  prevday        возвращает предыдущую дату для указанной даты

  Пример:
    {params.date.beginmonth.prevday} - возвращает дату конца предыдущего
    месяца для параметра "date"

    {SYSTEM.WORK_DATE.nextday.nextday} - возвращает послезавтрашную дату


==============================================================================

  Подстановки в наборе данных
  ----------------------------------------------------------------------------

  Сервер:

    <Имя_набора_данных>.<Имя_колонки> - возвращает строку - список всех
    значений колонки через запятую или единичное значение

  Excel:
  
    <Имя_набора_данных>.<Имя_колонки> - возвращает Range - список всех
      значений колонки

    <Имя_набора_данных>.<Имя_колонки>.index - возвращает порядковый номер
      колонки начиная с нуля


==============================================================================

  Понятие источника данных
  ----------------------------------------------------------------------------

  Источник данных - минимальная единица, которую может быть подключена
  к отчету для получения данных.

  Один источник возвращает один и более наборов данных.

  Источник данный может принимать параметры, которые будут влиять на
  возвращаемые данные.

  Источник данных однозначно определяется по имени внутри отчета.

  Набор данных в источнике определяется по составному имени:
    <Имя_источника_данных>.<Имя_набора_данных>

  Один из возвращаемых наборов данных, является основным возвращаемым
  набором данных источника, и адресуется упрощенно:

    <Имя_источника_данных>
    
  Имя такого источника данных должно быть "result".
  Такой набор данных можно адресовать и по полному имени:
    <Имя_источника_данных>.result

  Пример результата выполнения источника:

    <datasource NAME="Peoples">
      <dataset NAME="result">
        <columns>
          <column NAME="name" TYPE="string" />
          <column NAME="age"  TYPE="integer"/>
        </columns>
        <source>
          <row name="Иванов"   age="30"/>
          <row name="Smirnoff" age="20"/>
          <row name="Потапов"  age="40"/>
        </source>
      </dataset>
    </datasource>

==============================================================================

  Параметры
  ----------------------------------------------------------------------------

  Значения параметров источников могут определятся как:
    - параметры введенные пользователем,
    - параметры полученные из результирующего набора данных другого источника,
    - функции от этих параметров,
    - константы

  Различные источники могут поддерживать свои типы параметров.

  Параметры могут отличаться по их представлению в пользовательском
  интерфейсе.

  Какие параметры будут передаваться в источник, определяется в отчете.

==============================================================================

  Подстановки
  ----------------------------------------------------------------------------

  Набор данных в источнике определяется по составному имени:
    <Имя_источника_данных>.<Имя_набора_данных>

  Если один из наборов данных, возвращаемый источником имеет имя "result",
  то вместо формы:
    <Имя_источника_данных>.result
  можно использовать сокращенную:
    <Имя_источника_данных>


==============================================================================

  Отчет
  ----------------------------------------------------------------------------

  В отчете определяются:
    - параметры, вводимые пользователем
    - параметры, передаваемые источникам
    - источики
    - элементы компоновки отчета.

  В системе не может быть двух отчетов с одинаковым именем.

  У каждого отчета есть уникальный идентификатор.

  По уникальному имени отчета или его идентификатору происходит определение
  конкретного отчета например, исполнителем отчетов "REPORTEXECUTER" или
  объектом "REPORTPRINTER".

  С каждым отчетом связывается файл шаблона Excel.

==============================================================================

  Параметры отчета
  ----------------------------------------------------------------------------

  В параметрах отчета, в отличие от параметров источников, определяются
  параметры которые определяют визуальное отображение параметров в форме.

  * Константных параметры (и параметры-выражений) не визуализируются, так что
    задавать им параметры визуализации не имеет смысла.

==============================================================================

  Типы данных и визуальные элементы
  ----------------------------------------------------------------------------

  В дополнение к типам данных, определенных для наборов данных, параметры
  отчета могут иметь следующие типы, определяющие их пользовательское
  представление:

  Тип               Название типа    Формат Excel  тип Java

  перечисление      string           текстовый     String
  ссылка            reference        текстовый     String


  Перечисление
  ------------

  В перечислении определяются варианты значения в виде пар 
    "значение" - "отображаемый текст".

  Перечисления представляются в виде комбобоксов


  Ссылка
  ------

  Ссылка позволяет выбирать значения из стандартных справочников, определенных
  в системе.


==============================================================================

  Передача результатов источников другим источникам в качестве параметров
  ----------------------------------------------------------------------------

  Для передачи в один источник параметров, взятых из результата работы другого
  источника нужно создать параметр-константу, но значение этого параметра
  определить как подстановку.
  Для этого в параметр "Значение" надо вписать подстановку в фигурных скобках.

  Возможные подстановки описываются в разделах "Подстановки - Сервер" для
  каждого типа.

  Например:
    {SYSTEM.WORK_DATE}

  Кроме того для некоторых типов (см. в разделах "Подстановки - Сервер")
  определены функции.

  Например:
    {SYSTEM.WORK_DATE.beginyear}

==============================================================================

  Порядок вычислений
  ----------------------------------------------------------------------------
  Источники выполняются в порядке определения.
  Источник может получить доступ только к данным источников, определенных
  перед этим источником.

  Сначала выполняется системный источник "SYSTEM", затем все остальные.

  Подстановка значения параметру-константе происходит при первой передаче
  этого параметра подписанному на него источнику.

  Если параметр-константа не был затребован ни одним источником, он вычислится
  после отработки всех источников перед сохранением параметров в набор данных
  "params".


==============================================================================

  Типы источников
  ----------------------------------------------------------------------------

  Источников в системе могут быть следующих типов:

  - Внешние - определяются отдельно от отчетов и могут быть использованы
    в различных отчетах.

  - Внутренние - определяются внутри отчета и не могут быть использованы
    отдельно.

  - Специальные.

==============================================================================

  Внешние источники
  ----------------------------------------------------------------------------

  Каждый внешний источник данных имеет уникальное имя, описание и класс-
  обработчик.

  Во всех внешних источниках определяются следующие элементы:
  - параметры источника
  - выходные данные источника
  - настройки источника

==============================================================================

  Создание источника
  ----------------------------------------------------------------------------

  Внешние источники создаются и редактируются в модуле "Источники данных"
  (пункт меню "Сервис -> Редактировать источник данных").
  

==============================================================================

  SQL-источник
  ----------------------------------------------------------------------------

  В настройках SQL-источника определяется SQL-выражение.

  Подстановки параметров в текст SQL-запроса делаются в фигурных скобках.

  Чтобы получить описание параметров и результата SQL-запроса, необходимо
  вызвать пункт меню "Получить параметры" на объекте "Настроки". Это работает
  и для других источников.

  Если SQL задан правильно, то создадутся описания параметров и выходных
  данных.

  Не все JDBC-драйвера могут вернуть типы параметров SQL-запроса - в этом
  случае их надо указывать самим.

  Пример описания SQL-источника:

    <datasource>
      <params>
        <param name="param1"
          type="long"
          default="1"
          caption="Идентификатор"
          required="False"
          />
      </params>
      <settings
        sql="select col1,col2 from table1 where col1={param1}"
        />
      <output>
        <dataset name="result">
          <columns>
            <column name="col1" type="long"   caption="Столбец1"/>
            <column name="col2" type="string" caption="Столбец2"/>
          </columns>
        </dataset>
      </output>
    </datasource>

==============================================================================

  Типы параметров
  ----------------------------------------------------------------------------
  Типы параметров SQL-источника соотвествуют типам набора данных.

==============================================================================

  ServerProvider-источник
  ----------------------------------------------------------------------------

  Источик предназначен для получения данных от любого SERVERPROVIDER.

  Использовать этот источник удобно для получения источника отчета для печати
  списка документов.

  В настройках источника определяется только имя SERVERPROVIDER.

  После чего надо вызвать пункт меню "Получить параметры" на объекте
  "Настроки", в результате чего от провайдера будут получены описания
  параметров и выходных данных.

==============================================================================

  Типы параметров
  ----------------------------------------------------------------------------

  Массив значений
  ---------------

  Некоторые источники в некоторых своих параметрах могут поддерживать
  тип параметра - массив значений.

  Таким источникам можно, например, передавать данные множественного выбора из
  справочников или массив значений колонки набора данных, полученного ранее.

  Использование этого параметра должен поддерживать отчет (и, соответствено
  источник), печатающий список документов.

  Параметры "Массив значений" поддерживает также и следующий источник.


  sort_order
  ----------

  У ServerProvider есть специальный параметр типа строка, с именем 
  "sort_order", поддерживаемый не всеми провайдерами.
  Этот параметр определяет сортировку.
  В параметре перечисляются названия колонок данных, разделенные запятыми.
  Символ "-" перед именем колонки означает сортировку по убыванию, иначе - 
  по возрастанию.
  Этот параметр поддерживает, например, TableProvider.

  Использование этого параметра должен поддерживать отчет (и, соответствено
  источник), печатающий список документов.


==============================================================================

  CustomQueryProvider-источник
  ----------------------------------------------------------------------------

  Его описание состоит из:

  - выражение FROM
  - выражение WHERE
  - выражение ORDER BY
  - выражение GROUP BY
  - выражение HAVING
  - параметры SQL-запроса
    Описание параметр:
      - Название
      - Тип
      - SQL-выражение
      - Список
      - HAVING-параметр
      - masksize-параметр
        
  - колонки результирующего набора данных
    Описание колонки, дополнительные поля:
      - SQL-выражение

==============================================================================

  Типы параметров
  ----------------------------------------------------------------------------

  Массив значений
  ---------------
  Для обычных типов данных, если установить параметр "Список" равным True, то
  такой параметр станет поддерживать массив значений.

  Фильтрация кодов
  ----------------
  Помимо обычных типов данных, для работы с фильтрами масок предусмотрено
  поле mask_size - если оно указано, то такое поле будет фильтроваться по
  части маски следующим образом:
  Если значение введено неполностью, то будет произведена фильтрация по
  начальным цифрам целочисленного значения расширенного нулями слева до
  masksize цифр.
  Используется для кодов.
  Значение параметра может быть множественным и содержать отрицания ("-")
  SQL-выражения для такого параметра может быть только простым указанием
  поля: {имя_поля}.

  Но задавать так маски кодов нежелательно - вместо этого надо указывать
  непосредственно тип.
  Для этого используется специальный тип BudgetCode.<Имя_Кода>
  например: BudgetCode.KESR.
  В этом случае размер маски возьмется из определения кода в таблице CODETYPE.

==============================================================================

  Специальные источники
  ----------------------------------------------------------------------------

==============================================================================

  Union-источник
  ----------------------------------------------------------------------------

  Источник позволяет последовательно объединить несколько наборов данных
  (в том числе с различной структурой) в один и отсортировать его.

  В источнике определяются:
  
    Исходные наборы данных

    Определение колонок результирующего набора данных.

      Для каждой колонки результата определяется ее исходная колонка в кажом
      наборе данных.

      Если нет отображения колонки на какой-либо из исходных наборов данных,
      то ее значения для этого набора данных будут пустыми.

      Можно задать фиксированное отображение колонки для исходного набора
      данных, если в отображении на исходный набор для колонки не указать
      колонку исходного набора данных а указать фиксированное значение.

    Сортировка

      Сортировка работает для стандартных типов наборов данных.

      Минимальным значением считается null.


==============================================================================

  Grouping-источник
  ----------------------------------------------------------------------------

  Источник позволяет сгруппировать исходный набор данных по ключу (ключам).

  В источнике определяются:

    Исходный набор данных

    Колонки группировки

    Колонки результата

      В каждой колонке результата определяется ее имя тип, а также
        Имя исходной колонки и
        Операция.

   Операции
     общие:
       count         - количество исходных строк в группе
       first         - значение из первой исходной строки группы
       last          - значение из последней исходной строки группы
       firstrow      - номер первой исходной строки группы
       lastrow       - номер последней исходной строки группы
       firstexisting - первое непустое значение
     численные:
       sum           - сумма значений группы
       min           - минимальное значение в группе
       max           - максимальное значение в группе

   Группировка происходит последовательно, поэтому если необходимо
   группировать все совпадающие ключи, а не последовательности строк с
   совпадающими ключами, то исходный набор даннх должен быть сортирован
   по этим ключам.

==============================================================================

  Системный источник
  ----------------------------------------------------------------------------

  Источник данных возвращает набор системных данных.

  Источник всегда подключается к отчетам.
  Название источника: "SYSTEM".

  Выходные наборы данных
    - набор данных result
      колонки:
        - WORK_DATE  - рабочая дата
        - BUDGET_ID  - рабочий бюджет
        - USER_ID    - пользователь
        - SESSION_ID - внутренний идентификатор сессии

  Cистемный источник всегда выполняется первым, так что его результат всегда
  доступен для подстановки в качестве параметров в другие источники.
  Результат системного источника как и остальных источников, может
  использоваться и при подстановках в шаблоне Excel, например:

    !={SYSTEM.WORK_DATE}




==============================================================================

  Компоновка отчета
  ----------------------------------------------------------------------------
  Для визуализации отчета обычно недостаточно одних лишь наборов данных.
  Например необходимо визуализировать данные по группам, формировать
  вычисляемые поля, и проч.

  Сейчас есть два вида компоновок: таблицы и матрицы.

  Компоновки используются только в Excel и сильно с ним связаны.

==============================================================================

  Шаблоны и подстановки
  ----------------------------------------------------------------------------

==============================================================================

  Маркеры, обрабатываемые генератором отчетов
  ----------------------------------------------------------------------------

  Для обработки ячейки генератором отчета первым символом в ячейке должен быть
  символ "!".

  Например:

          A          B                 C
     1    .          .                 .
     2  Дата:   !={params.date}        .
     3    .          .                 .
     4  Итого:  !=SUM({table.amount})  .
     5    .          .                 .

  Чтобы выражение в котором первый символ "!" не обрабатывалось генератором,
  вместо одного символа "!" надо указать два ("!!").

  Например:

          A          B                 C
     1    .          .                 .
     2  !!Эта ячейка должна начинаться с "!"
     3    .          !!                .
     4  В ячейке B3 должен стоять "!"  .
     5    .          .                 .


  Генератор отчетов обрабатывает маркеры двух типов:

  - маркер "define"

    Маркер "define" это маркер, располагающийся в первом столбце
    и начинающийся со строки "!define", за которой, разделенные точкой
    с запятой, следуют параметры.

    Строки, маркированные этим маркером в шаблон не входят.

    Содержимое всех колонок строки, помеченной этим маркером, кроме первой,
    игнорируются.


  - встроенный в шаблон маркер подстановки

    Любой другой маркер, отличный от маркера "define"


==============================================================================

  Маркеры "define"
  ----------------------------------------------------------------------------

  Формат тегов:
    <!><define> { <;> ( "value" | ( <tag> { <:> <tag> } [ <:> "value" ] ) }
    значения должны указываться в кавычках
    ограниченно можно использовать значения без кавычек:
      полная форма имен шаблонов (с тегом) : name:"ИМЯ"
      сокращенная форма                    : "ИМЯ"
      форма для совместимости              : ИМЯ

  * подстановка кавычек внутри кавычек соответствует java - <\">


  Маркеры "define" бывают двух типов:

  Маркеры блоков
  --------------

    Маркеры блоков начинается маркером "define" с параметром "begin"
    и заканчивается маркером "define" с параметров "end".

    Параметры begin и end могут находиться на любом месте в списках
    параметров define.

      Например, маркеры "!define;block;begin" и "!define;begin;block"
      эквивалентны.

    Первый параметр в маркере начала, после исключения "begin" из маркера
    - это имя блока.

    В маркере конца блока дополнительные параметры игнорируются.

      Например, маркеры "!define;block;end" и "!define;end"
      эквивалентны. Однако рекомендуется маркировать маркер конца
      аналогично началу.

    Блоки, ограниченные маркерами могут содержать другие блоки.

    Блоки, несодержащие другие блоки называются терминальными.

    Содержимое нетерминальных блоков, не являющееся вложенными блоками,
    игнорируется.


  Простые маркеры "define"
  ------------------------

    Любой другой, кроме блочного, маркер "define".

    Например:

            A                        B                C
       1    .                        .                .
       2  !define;autohideempty:true .                .
       3    .                        .                .


  Вариантные маркеры
  ------------------

    Вариантные шаблоны вкладываются в обычный шаблон, если их более одного.
    Заголовок варианта помечается тегом choice с указанием выражения:

    Пример:

      ...
      !define;begin;header
      !define;begin;choice:"{rowcount} > 0"
      ...
      !define;end;choice
      !define;begin;choice:"{rowcount} = 0"
      ...
      !define;end;choice
      !define;begin
      ...
      !define;end
      !define;begin
      ...
      !define;end
      !define;end;header
      ...
  
    Выбор шаблона происходит так:
      для всех шаблонов группы выполняется:
        если есть выражение выбора и его значение = true, то:
          подставить этот шаблон
      если ни одно условие не прошло или нет шаблонов с формулами то:
        подставляются безусловные шаблоны


==============================================================================

  Маркеры форматирования шаблонов
  ----------------------------------------------------------------------------

  Автоподбор высоты
  -----------------

    Для автоподбора высоты шаблона к определению define надо добавить маркер
    autofitheight.

    Пример:

      ...
      !define;begin;header;autofitheight
      ...
      !define;end;header
      ...

    Если не все строки шаблона надо делать с автоподбором высоты, то он
    разбивается как и в случае с choice и делается вложенным.

    Пример:
  
      ...
      !define;begin;header
      !define;begin;autofitheight
      ... с автоподбором высоты
      !define;end
      !define;begin
      ... без автоподбора высоты
      !define;end
      !define;end;header
      ...

==============================================================================

  Типы данных Excel
  ----------------------------------------------------------------------------

  Форматы данных:
    строковый тип                       - "@"
    тип даты                            - "YYYY-MM-DD"
    вычисляемых колонок строкового типа - автоматический
    остальных типов                     - автоматический


  Значение NULL представляется в виде строки из одного символа пробела " ".

  Для преобразования в 0 значений колонки, которые могут быть NULL, можно
  воспользоватся Excel-функцией SUM().

  Excel-функции, способные принимать группы значений обычно понимают что " "
  означает 0.

  * При подстановки даты в шаблоне необходимо указывать формат ячейки.

  * Если параметр - множественный, то необходимо указывать его тип как
    строковый.

  
==============================================================================

  Вычисляемые выражения Excel
  ----------------------------------------------------------------------------

  Выражение соответствует синтаксису Excel:

  - Если варажение предваряет знак равенства "=" , это выражение - формула

  - В противном случае - это воспринимается Exel как строка символов
    и в Excel не рассчитывается, хотя подстановка параметров в такое
    выражение и будет произведена.

    Это можно использовать, например, для проверки подстановок.

    В шаблоне того же эффекта можно добиться установив тип формата ячейки
    на "Текст".

  Для подстановки в Excel-ячейке выражения генератора отчетов оно
  указывается в фигурных скобках.

  Результатом подстановки будет адрес ячейки или одномерный диапазон ячеек.

  В матрицах возможно получение двумерного диапазона данных.

  * Крайне нежелательно в выражениях excel адресовать Excel-ячейки
    напрямую, за исключением сформированных в Excel "справочников".

  * "формулы массива" не поддерживаются, поскольку в них нет необходимости,
    кроме того, определение диапазонов в шаблонах для "формул массива" было
    бы слишком громоздким. Хотя и определение в шаблонах диапазонов
    может понадобиться в дальнейшем.

  * Использование названий столбцов таблиц, совпадающих со служебными
    названиями:
    - имена таких столбцов заключаются в двойные кавычки

==============================================================================

  Описания контекстов
  ----------------------------------------------------------------------------

  Для описания контекстов подстановок используются следующие обозначения
    (пробелы игнорируются, прочие символы указываются в угловых скобках):

    ...     - обозначает один и более символов

    ?       - обозначает ноль и более символов

    "..."   - обозначает литеральную подстановку указанной в кавычках
              строки

    ""      - обозначает пустую строку

    <имя>   - обозначает имя
              имя начинается с буквы или подчеркивания за которым
              следует произвольное количество символов букв, цифр
              и знаков подчеркивания
              (<буква> | "_" ) { <буква> | "_" | <цифра> }

    <"имя"> - обозначает имя или имя в кавычках
              ( <имя> | ( <"> <имя> <"> ) )


==============================================================================

  Типы объектов компоновки
  ----------------------------------------------------------------------------


==============================================================================

  Набор данных
  ----------------------------------------------------------------------------

==============================================================================

  Контексты набора данных
  ----------------------------------------------------------------------------

  Контекст набора данных TDataSetExprContext
  ------------------------------------------

    Шаблоны: "header", "footer"

    Родительский контекст: Глобальный контекст TGlobalExprContext

      <"имя_колонки">         -> возвращает колонку таблицы
      <"имя_колонки"> "." ... -> контекст колонки ...
      ?                       -> родительский контекст


  Detail-контекст набора данных TDataSetDetailContext
  ---------------------------------------------------

    Шаблоны: "detail"

    Родительский контекст: Контекст набора данных

      "row"                   -> возвращает номер строки таблицы
      "row" ...               -> ошибка
      "table" "." ...         -> родительский контекст ...
      "table" ?               -> ошибка
      <"имя_колонки"> "." ... -> контекст колонки ...
      <"имя_колонки">         -> возвращает ячейку таблицы
      <"имя_колонки"> ...     -> ошибка
      ?                       -> родительский контекст ...


  Контекст колонки набора данных TDataSetColumnExprContext
  --------------------------------------------------------

    Родительский контекст: Контекст набора данных

      "columnindex"     -> возвращает номер столбца
      "columnindex" ... -> ошибка
      ?                 -> родительский контекст ...


  Контекст вычисляемой колонки
  ----------------------------

    ? -> Контекст колонки, Detail-контекст


==============================================================================

  Шаблоны набора данных
  ----------------------------------------------------------------------------

  Шаблоны набора данных состоят из блока, в который входят блоки заголовка
  и нижнего колонтитулы таблиц и блок данных.

  Пример шаблона:

          A                     B         C
     1    .                     .         .
     2  !define;DATASET;begin   .         .
     3  !define;header;begin    .         .
     4  №                     Имя       Сумма
     5  !define;header;end      .         .
     6    .                     .         .
     7  !define;detail;begin    .         .
     8  !={row}               !={NAME}  !={AMOUNT}
     9  !define;detail;end      .         .
    10    .                     .         .
    11  !define;footer;begin    .         .
    12  Итого:                  .       !=SUM({AMOUNT})
    13  !define;footer;end      .         .
    14  !define;DATASET;end     .         .
    15    .                     .         .

    Строки 2,14 объявляют нетерминальный блок DATASET.
    В него входят терминальные блоки: header (3-5), detail (7-9)
    и footer (11-13).
    Строки 6,10 игнорируются.


  В принципе, аналогичного результата можно было бы добиться с помощью
  шаблона:


          A                     B         C
     1    .                     .         .
     4  №                     Имя       Сумма
     2  !define;DATASET;begin   .         .
     7  !define;detail;begin    .         .
     8  !={row}               !={NAME}  !={AMOUNT}
     9  !define;detail;end      .         .
    14  !define;DATASET;end     .         .
    12  Итого:                  .       !=SUM({DATASET.AMOUNT})
    15    .                     .         .

    Здесь итог вынесен за пределы контекста DATASET в глобальный
    и требуется явное указание.


==============================================================================

  Таблица
  ----------------------------------------------------------------------------

  Компоновка "Таблица" реализует следующие операции:

    - вычисление данных в колонках (вычисляемые колонки)
    - сортировка и удаление дупликатов (в том числе по вычисляемым колонкам)
    - группировка (в том числе по вычисляемым колонкам)
    - фильтрация по вычисляемым колонкам (в том числе групп)
    - визуальная группировка
    - визуальная группировка на отдельных страницах

  Описание таблицы состоит из:

    Ссылка на исходный набор данных.

      Ссылаться можно на описанную ранее таблицу.

    Список колонок

      В колонке помимо названия и типа определяются:

        Название исходной колонки из исходного набора данных.

          Если неопределено, то эта колонка - вычисляемая.

        Excel-выражение.

          Задается для вычисляемых колонок.

    Список колонок сортировки

    Необязательный флаг "Удалять одинаковые ключи"

      Будут удалены строки с одинаковые ключами (по списку колонок сортировки)
      По умолчанию false

    Необязательное excel-выражение Фильтра

      Будут удалены строки, где выражение фильтра примет значение false
      По умолчанию пустая строка, что соответствует true.

    Список группировок

      В кажой группировке описываются:

        Название столбца набора данных для группировки

        Тип группировки (по умолчанию - простой)
          simple   - простой (по значению)
          pathtree - дерево (по пути к узлу)
                     для дерева, строящегося по пути к узлу должен указываться
                     разделитель элементов пути
        
        Разделитель элементов пути (для группировки типа pathtree)

        Необязательное excel-выражение Фильтра

          Будут удалены строки группировки,
          (и соответствующие подгруппировки и собственно строки таблицы)
          где выражение фильтра примет значение false.
          По умолчанию пустая строка, что соответствует true.

        - Признак вывода группировки на отдельной странице
          По умолчанию false.

        - Excel-выражение названия страницы с группировкой.
          По умолчанию ={group}.

          * По ограничениям Excel название страницы не должно превышать 31
            символ, и совпадать с названиями других страниц. (см. также
            список зарезервированных названий страниц)


==============================================================================

  Группировка
  ----------------------------------------------------------------------------

  Пример работы группировки

  Допустим исходная таблица выглядит так:

       col1 col2 col3 col4 sum
    1  1    1    1    a    1
    2  1    1    2    b    2
    3  1    2    1    c    3
    4  1    2    2    d    4
    5  2    1    1    e    5
    6  2    1    2    f    6
    7  2    2    1    j    7
    8  2    2    2    h    8
  

  Таблица отсортирована по col1, col2, col3
  Определим группы col1, col2:

  Группы сформируются следующим образом

    группа col1:
         идентификатор_группы  от до  подгруппы_от подгруппы_до  строки
      1  1                     1  4   1            2             1,2,3,4
      2  2                     5  8   3            4             5,6,7,8


    группа col2:
         идентификатор_группы  от до  строки
      1  1                     1  2   1,2
      2  2                     3  4   3,4
      3  1                     5  6   5,6
      4  2                     7  8   7,8


  если определить в группе col2 вычисляемую колонку sum=SUM({sum}), получим:
  
    группа col2:
         идентификатор_группы  от до  sum
      1  1                     1  2   3
      2  2                     3  4   7
      3  1                     5  6   11
      4  2                     7  8   15

  если определить в группе col1 вычисляемые колонки sum=SUM({sum})
  и sum1=SUM({groups.col2.sum}), то получим:

    группа col1:
         идентификатор_группы  от до  sum  sum1
      1  1                     1  4   10   10
      2  2                     5  8   26   26

==============================================================================

  Группировка по пути к узлу дерева
  ----------------------------------------------------------------------------

  Пример работы группировки

  Допустим исходная таблица выглядит так:

       path col1 sum
    1       1    0
    2       2    0
    3  1    1    0
    4  1    2    0
    5  1.1  1    1
    6  1.1  2    2
    7  1.2  1    3
    8  1.2  2    4
    9  2    1    0
   10  2    2    0
   11  2.1  1    5
   12  2.1  2    6
   13  2.2  1    7
   14  2.2  2    8

  Таблица отсортирована по path, col1
  Определим группу path типа pathtree с разделителем ".":

  Тогда уровни сформируются следующим образом:

    level 0 (корневой - есть всегда)
         идентификатор_узла  от до  подузлы_от подузлы_до
      1                      1  2   1          2

    level 1:
         идентификатор_узла  от до  подузлы_от подузлы_до
      1  1                   3  4   1          2
      2  2                   9  10  3          4

    level 2:
         идентификатор_узла  от до  подузлы_от подузлы_до
      1  1                   5  6   0          0
      2  2                   7  8   0          0
      3  1                   11 12  0          0
      4  2                   13 14  0          0


  если определить в группе col2 вычисляемую колонку
    sumleaf=IF({childs.count} = 0, {sum}, SUM(DEFVAL({childs.sumleaf}, 0)))

    то получим:
  
    level 0
         идентификатор_узла  от до  sumleaf
      1                      1  2   36

    level 1:
         идентификатор_узла  от до  sumleaf
      1  1                   3  4   10
      2  2                   9  10  26

    level 2:
         идентификатор_узла  от до  sumleaf
      1  1                   5  6   3
      2  2                   7  8   7
      3  1                   11 12  11
      4  2                   13 14  15

==============================================================================

  Контексты таблицы
  ----------------------------------------------------------------------------


  Контекст таблицы TTableExprContext
  ----------------------------------

    "groups" "." <"имя_группы"> "." -> контекст группы
    "groups" ?                      -> ошибка
    ?                               -> контекст набора данных


  Detail-контекст таблицы TTableDetailContext
  -------------------------------------------

    Шаблоны: "detail" == ( [ { "group" ";" } ] "detail" )

    "groups" "." <"имя_группы"> "." "rowcount" -> 
      возвращает ячейку с количеством строк таблицы в этой группе

    "groups" "." <"имя_группы"> "." "rowcount" ? -> ошибка
    "groups" "." <"имя_группы"> "." "groupcount" ->
      возвращает ячейку с количеством строк в подгруппе этой группы

    "groups" "." <"имя_группы"> "." "groupcount" ? -> ошибка
    "groups" "." <"имя_группы"> "." <"имя_колонки_группы"> ->
      возвращает ячейку группы

    ? -> Detail-контекст набора данных ...


  Контекст группы таблицы TTableGroupExprContext
  ----------------------------------------------

    Родительский контекст: Контекст таблицы

    ? -> Контекст набора данных ...


  Detail-контекст группы таблицы TTableGroupDetailContext
  -------------------------------------------------------

    Шаблоны: "header", "footer"
      == ( [ { "group" ";" } ] ( "header" | "footer" ) )

    "groups" "." <"имя_группы"> "." "rowcount" ->
      возвращает ячейку или выражение с количеством строк таблицы в группе

    "groups" "." <"имя_группы"> "." "rowcount" ... -> ошибка
    "groups" "." <"имя_группы"> "." "groupcount" ->
      возвращает ячейку или выражение с количеством строк в подгруппе этой
      группы

    "groups" "." <"имя_группы"> "." "groupcount" ... -> ошибка
    "groups" "." <"имя_группы"> "." <"имя_колонки_группы"> "." ... ->
      Контекст колонки группы таблицы

    "groups" "." <"имя_группы"> "." <"имя_колонки_группы"> ->
      возвращает ячейку или колонку

    "groups" "." <"имя_группы"> "." <"имя_колонки_группы"> ... -> ошибка
    "groups" "." <"имя_группы"> "." ... -> контекст группы таблицы ...
    "groups" ...    -> ошибка
    "group" "." ... -> контекст группы таблицы ...
    "group"         -> возвращает ячейку колонки группировки
    "group" ...     -> ошибка
    "table" "." ... -> контекст таблицы ...
    "table" ...     -> ошибка

    "node"                             -> идентификтатор узла в паренте
    "node" "." "level"                 -> уровень (значение) (0 - корень)
    "node" "." "level" ...             -> ошибка
    "node" "." "levelcount"            -> количество уровней (значение)
    "node" "." "levelcount" ...        -> ошибка
    "node" "." "sublevelcount"         -> количество подуровней (ячейка) (levelcount-level)
    "node" "." "sublevelcount" ...     -> ошибка
    "node" "." "synthetic"             -> узел - синтетический (не имеет исходных данных)
    "node" "." "synthetic" ...         -> ошибка
    "node" "." <"fieldname">           -> поле этого узла
    "node" "." <"fieldname"> ...       -> ошибка
    "node" ...                         -> ошибка
    "childs" "." "count"               -> количество подузлов этого узла
    "childs" "." "count" ...           -> ошибка
    "childs" "." <"fieldname">         -> колонка в подузле этого узла или пусто
    "childs" "." <"fieldname"> ...     -> ошибка
    "childs" ?                         -> ошибка
    "parent"                           -> =parent.node
    "parent" <.> <"fieldname">         -> =parent.node."fieldname"

    <"имя_колонки_группы"> "." ...  -> контекст колонки группы ...
    <"имя_колонки_группы">          -> возвращает ячейку
    <"имя_колонки_группы"> ...      -> ошибка
    <"имя_колонки_таблицы"> "." ... -> контекст колонки таблицы ...
    <"имя_колонки_таблицы">         -> возвращает колонку или ячейку,
      если это колонка группировки этой группы

    <"имя_колонки_таблицы"> ...     -> ошибка
    ? ->  Detail-контекст таблицы ...



==============================================================================

  Шаблоны таблиц
  ----------------------------------------------------------------------------

  Шаблоны таблиц состоят из блока таблицы, в который входят
  блоки заголовка и нижнего колонтитулы таблиц, вложенные блоки
  группировок с блоками заголовков и нижних колонтитулов, и блок данных.

  Пример шаблона с двумя группировками:

                A             B          C          D       E
     1          .             .          .          .       .
     2  !define;TABLE;begin   .          .          .       .
     3  !define;header;begin  .          .          .       .
     4       Группа      Подгруппа  № в подгруппе  Имя    Сумма
     5  !define;header;end    .          .          .       .
     6          .             .          .          .       .
     7  !define;group;0;begin .          .          .       .
     8  !define;header;begin  .          .          .       .
     9      !={group}         .          .          .       .
    10  !define;header;end    .          .          .       .
    11          .             .          .          .       .
    12  !define;group;1;begin .          .          .       .
    13  !define;header;begin  .          .          .       .
    14          .         !={group}      .          .       .
    15  !define;header;end    .          .          .       .
    16          .             .          .          .       .
    17  !define;detail;begin  .          .          .       .
    18          .             .   !={grouprow}  !={NAME}  !={AMOUNT}
    19  !define;detail;end    .          .          .       .
    20          .             .          .          .       .
    21  !define;footer;begin  .          .          .       .
    22          .             .  Итого по подгруппе:   !=SUM({AMOUNT})
    23  !define;footer;end    .          .          .       .
    24  !define;group;1;end   .          .          .       .
    25          .             .          .          .       .
    26  !define;footer;begin  .          .          .       .
    27          .             .    Итого по группе: .  !=SUM({AMOUNT})
    28  !define;footer;end    .          .          .       .
    29  !define;group;0;end   .          .          .       .
    30          .             .          .          .       .
    31  !define;footer;begin  .          .          .       .
    32          .             .        Итого:       .  !=SUM({AMOUNT})
    33  !define;footer;end    .          .          .       .
    34  !define;TABLE;end     .          .          .       .
    35          .             .          .          .       .

    Строки 2,34 объявляют нетерминальный блок TABLE.
    В него входят терминальные блоки: header (3-5), footer (31-33) 
    и нетерминальный блок группы (7-29), в которую входят
    терминальные блоки: header (9-10) и footer (36-28)
    и нетерминальный блок подгруппы (12-24), в которую входят
    терминальные блоки: header (13-15), footer (21-23) и detail(17-19).
    

  Номер группы в маркерах группы необязателен - он выполняет функции
  комментария.


==============================================================================

  Порядок расчета таблиц
  ----------------------------------------------------------------------------

    1. Сортировка
    2. Формирование групп
    3. Расчет вычисляемых столбцов групп
    4. Расчет вычисляемых столбцов таблицы
    5. Фильтрация
    6. Если фильтрация была произведена, то повторно выполняются пункты 2-4.

         
  Вычисляемые колонки сортировки и группировки

    Создается промежуточная таблица, в которой определяются вычисляемые
    колонки.

    В результирующей таблице в качестве источника данных определяется
    промежуточная таблица.
    Теперь с сортировкой и группировкой в результирующей таблице проблем не
    будет - поскольку необходимые для этого столбцы уже рассчитаны при
    формировании промежуточной таблицы.


  Вычисляемые колонки групп, зависимые от вычисляемых колонок таблицы

    Такие подстановки допустимы в шаблоне таблицы, но не в вычисляемых
    колонках.
    Если подстановок в шаблоне недостаточно, то необходимо воспользоваться
    промежуточной таблицей.


==============================================================================

  Работа с Excel
  ----------------------------------------------------------------------------


==============================================================================

  Формулы Excel
  ----------------------------------------------------------------------------

  Вместо локальных названий функций Excel используются английские названия,
  работающие вне зависимости от локали.

  Список соответствия русских названий английским есть в справке по
  WorksheetFunction. см. Приложение.

  Английская локаль отличается от русской например разделителем параметров
  функции: в русской локали - ";" в английской - ","

==============================================================================

  Конкатенация строк
  ----------------------------------------------------------------------------

  Для конкатенация строк в Excel вместо символа "+" используется символы "&".

  Пример:

    !="от " & {from} & " до " & {to}


  Для конкатенации значений колонки можно воспользоваться функцией CONCAT.

  Пример:

    != CONCAT({MyTable.MyColumn})


==============================================================================

  Выполнение join (lookup)
  ----------------------------------------------------------------------------

  Для подключения значений из наборов данных по ключу в Excel вместо
  стандартной функцией LOOKUP лучше воспользоваться функцией LOOKUPDEF.

  Пример lookup значения колонки CODE_ID в detail-контексте на таблицу
  CODE по колонке ID с возвратом результата из колонки NAME, если
  код CODE_ID не найден в таблице CODE, то возвращается пустая строка:

  !=LOOKUPDEF({CODE_ID},{CODE.ID},{CODE.NAME},"")


==============================================================================

  Использование вычисляемых колонок сортировки
  ----------------------------------------------------------------------------

  Сортировку по вычислемым колонкам можно сделать с использованием
  промежуточной таблицы.

  1. Сначала определяется промежуточная таблица с вычисляемыми колонками,
     которые будут использоваться для сортировки.

  2. Определяется результирующая таблица с источником-промежуточной таблицой.

  В результирующей таблице можно выполнять сортировку.


==============================================================================

  Использование вычисляемых колонок группировки
  ----------------------------------------------------------------------------

  Аналогично сортировке по вычисляемым колонкам.

  1. Сначала определяется промежуточная таблица с вычисляемыми колонками,
     которые будут использоваться для группировки.

  2. Определяется результирующая таблица с источником-промежуточной таблицой.

  В результирующей таблице можно выполнять группировку.

==============================================================================

  Наращиваемые итоги
  ----------------------------------------------------------------------------

  Иногда вычисления SUM по диапазону ячеек

    (c1 + с2 + ... cN)

  недостаточно и нужны наращиваемые итоги например вида

    (...((c1*k1 + c2)*k2 + ... cN)*kN

  Для получения таких итогов нужно обращатся к вычисленным в предыдущей строке
  подитогам.

  Чтобы реализовать ссылку на предыдущую ячейку можно воспользоваться функцией
  Excel OFFSET:

    OFFSET({подстановка_возвращающая_ссылку_на_одну_ячейку}, -1, 0, 1, 1)

  Для приведенного примера формула в вычисляемой колонке R будет иметь вид:

    ={C} * K + IF({row} = 1, 0, OFFSET({R}, -1, 0, 1, 1))

==============================================================================

  Преобразование пустых значений в значения по умолчанию
  ----------------------------------------------------------------------------

  В ряде случаев в результате подстановки может возвращаеться пустое значение,
  например в подстановке childs.имя_колонки, в случае если узел не имеет
  подулов. В результате этого, например, подстановка
    SUM({childs.имя_колонки})
  выдает ошибку.

  Чтобы ошибка не происходила, надо преобразовать пустое значение в более
  осмысленное - это и делает функция DEFVAL.

  Корректная подстановка в данном случае будет:
    SUM(DEFVAL({childs.имя_колонки}, 0))

==============================================================================

  Форматирование дебита/кредита
  ----------------------------------------------------------------------------

  Для форматирования дебита/кредита используются функции getDebitDisplayValue/
  getCreditDisplayValue из модуля ReporterAccountTools.XLA

  Пример:

    !=getDebitDisplayValue({DEBIT}, {CREDIT}, 0)

==============================================================================

  Форматирование кодов
  ----------------------------------------------------------------------------

  Для форматирования кодов используется функция getFormattedCode из модуля
  ReporterAccountTools.XLA

  Для использования этой функции в отчет нужно подключить стандартный
  справочный источник "CodeType" с именем "CodeType".

  Пример:

    !=getFormattedCode({KESR_CODE}, "KESR", ".")

==============================================================================

  Форматирование пути по коду
  ----------------------------------------------------------------------------

  Для форматирования пути по коду используется функция getCodePath,
  аналогичная по вызову функции getFormattedCode.

  Пример:

    !=getCodePath({KESR_CODE}, "KESR", ".")

  * Символ разделителя должен совпадать с символом разделителя элементов пути
    группы.

==============================================================================

  Приложение
  ----------------------------------------------------------------------------


==============================================================================

  Зарезервированные имена
  ----------------------------------------------------------------------------

  Зарезервированные имена наборов данных
    params - зарезервированный набор данных с параметрами отчета
    SYSTEM - системный источник
    define - маркер строки, не входящей в шаблон
    begin  - маркер начала шаблона, используется совместно с define
    end    - маркер конца шаблона, используется совместно с define

  Зарезервированные имена колонок
    __COLUMN__#{#}, где #-любая цифра - колонка, название которой не может
      быть представлено именем атрибута XML

    filtered        - системная колонка фильтра
    cascadefiltered - системная колонка каскадного фильтра (создается при
      наличии групповых фильтров)

  Зарезервированные имена страниц Excel
    __#{#}, где #-любая цифра - сгенерировання страница с данными
    _worksheets
    _datasets
    _params
    _*, где *-любое имя кроме вышеперечисленных - сохраненная страница
      шаблона

  В Excel-выражениях имена колонок могут совпадать с предопределенными
  в контексте полями. В этом случае имя колонки надо указывать в кавычках.
  Например:
    в контексте текущей строки таблицы
    {row} вернет номер текущей строки
    {"row"} вернет значение столбца "row" в текущей строке

  * Крайне нежелательно использовать в названиях иные символы кроме букв
    и цифр.

  * Соглашение:
    Пользовательские идентификаторы должны начинаться с большой буквы.

  * Крайне нежелательно определять невидимые вычисляемые поля для
    промежуточных вычислениях в шаблонах Excel - вместо этого надо
    использовать вычисляемые колонки

==============================================================================

  Стыковка с системой
  ----------------------------------------------------------------------------

==============================================================================

  Вызов отчета из меню
  ----------------------------------------------------------------------------

  Для вызова объекта из меню используется объект системы REPORTEXECUTER
  (Reporter.ReportExecuter).

  Конкретный отчет передается объекту REPORTEXECUTER по имени или
  идентификатору (параметры NAME и ID).

  1. Вариант
    1. Создается клиентский объект типа "Модуль" для вызова отчета.
       В параметрах этого объекта указывается
         NAME=Имя_Отчета
       или
         ID=Идентификатор_Отчета
       Первое предпочтительней.
    2. Создается меню, вызывающее этот клиентский объект.

  2. Вариант
    1. Создается меню, вызывающее клиентский объект REPORTEXECUTER.
       В параметрах этого объекта в меню указывается
         NAME=Имя_Отчета
       или
         ID=Идентификатор_Отчета
       Первое предпочтительней.

==============================================================================

  Документы
  ----------------------------------------------------------------------------

  Стандартно система вызывает отчеты двух видов:
    Печать документа
    Печать списка документов

==============================================================================

  Печать документов
  ----------------------------------------------------------------------------

  Печать документа вызывается из...
    ...документа и печатает один документ;
    ...модуля и печатает один текущий или все выбранные документы.

  Для каждого документа передается:
    DOC_ID           - ID
    DOCUMENT_ID      - ID документа
    DOCUMENTCLASS_ID - класс документа
    CAPTION          - название класса документа (отображается при печати)
    total            - всего печатается документов (отображается при печати)
    current          - порядковый номер текущего печатаемого документа
                       (отображается при печати)

  Для связи документа с reporter-ом необходимо в настройках класса документа
  задать клиентский объект печати равным REPORTPRINTER, а в параметрах
  печати указать имя (желательно) или идентификтор отчета: NAME=имя_отчета.

==============================================================================

  Печать списка документов
  ----------------------------------------------------------------------------

  Печать списка документов вызывается из...
    ...модуля и печатает список выбранных документов.

  Объекту печати передаются параметры:
    DOC_ID     - список ID
    sort_order - список текущих колонок сортировки

  Для связи модуля с reporter-ом необходимо в настройках этого клиентского
  объекта в его параметрах задать PRINTERCLIENTOBJECT=REPORTPRINTER и указать
  имя (желательно) или идентификтор отчета: NAME=имя_отчета.

==============================================================================

  Используемые в REPORTER.XLA библиотеки
  ----------------------------------------------------------------------------

  Visual Basic For Application (VBA6)
  Microsoft Excel 9.0 Object Library (Excel9.OLB)
  OLE Automation (stdol2.tlb)
  Microsoft XML, version 2.0 (msxml.dll)
  Microsoft Scripting Runtime (scrrun.dll)
  Microsoft Forms 2.0 Object Library (FM20.DLL)
  Microsoft Office 10.0 Object Library

==============================================================================

  Таблица соответствия русских названий формул английским
  ----------------------------------------------------------------------------

  ACOS                  Acos
  ACOSH                 Acosh
  ASIN                  Asin
  ASINH                 Asinh
  ATAN2                 Atan2
  ATANH                 Atanh
  COSH                  Cosh
  FРАСП                 FDist
  FРАСПОБР              FInv
  LN                    Ln
  LOG                   Log
  LOG10                 Log10
  PHONETIC              Phonetic
  SINH                  Sinh
  TANH                  Tanh
  ZТЕСТ                 ZTest
  АМГД                  Syd
  АМР                   Sln
  БДДИСП                DVar
  БДДИСПП               DVarP
  БДПРОИЗВЕД            DProduct
  БДСУММ                DSum
  БЕТАОБР               BetaInv
  БЕТАРАСП              BetaDist
  БЗ                    Fv
  БИЗВЛЕЧЬ              DGet
  БИНОМРАСП             BinomDist
  БСЧЁТ                 DCount
  БСЧЁТА                DCountA
  ВЕЙБУЛЛ               Weibull
  ВЕРОЯТНОСТЬ           Prob
  ВНДОХ                 Irr
  ВПР                   VLookup
  ВЫБОР                 Choose
  ГАММАНЛОГ             GammaLn
  ГАММАОБР              GammaInv
  ГАММАРАСП             GammaDist
  ГИПЕРГЕОМЕТ           HypGeomDist
  ГПР                   HLookup
  ГРАДУСЫ               Degrees
  ДДОБ                  Ddb
  ДЕНЬНЕД               Weekday
  ДИСП                  Var
  ДИСПР                 VarP
  ДМАКС                 DMax
  ДМИН                  DMin
  ДНЕЙ360               Days360
  ДОБ                   Db
  ДОВЕРИТ               Confidence
  ДСРЗНАЧ               DAverage
  ДСТАНДОТКЛ            DStDev
  ДСТАНДОТКЛП           DStDevP
  ЕНД                   IsNA
  ЕНЕТЕКСТ              IsNonText
  ЕОШ                   IsErr
  ЕОШИБКА               IsError
  ЕССЫЛКА               Ispmt
  ЕТЕКСТ                IsText
  ЕЧИСЛО                IsNumber
  ЗАМЕНИТЬ              Replace
  ЗАМЕНИТЬБ             ReplaceB
  И                     And
  ИЛИ                   Or
  ИНДЕКС                Index
  КВАДРОТКЛ             DevSq
  КВАРТИЛЬ              Quartile
  КВПИРСОН              RSq
  КЛОГИЧ                IsLogical
  КОВАР                 Covar
  КОРРЕЛ                Correl
  КПЕР                  NPer
  КРИТБИНОМ             CritBinom
  ЛГРФПРИБЛ             LogEst
  ЛИНЕЙН                LinEst
  ЛОГНОРМОБР            LogInv
  ЛОГНОРМРАСП           LogNormDist
  МАКС                  Max
  МВСД                  MIrr
  МЕДИАНА               Median
  МИН                   Min
  МОБР                  MInverse
  МОДА                  Mode
  МОПРЕД                MDeterm
  МУМНОЖ                MMult
  НАИБОЛЬШИЙ            Large
  НАИМЕНЬШИЙ            Small
  НАЙТИ                 Find
  НАЙТИБ                FindB
  НАКЛОН                Slope
  НЕЧЁТ                 Odd
  НОРМА                 Rate
  НОРМАЛИЗАЦИЯ          Standardize
  НОРМОБР               NormInv
  НОРМРАСП              NormDist
  НОРМСТОБР             NormSInv
  НОРМСТРАСП            NormSDist
  НПЗ                   Npv
  ОКРВВЕРХ              Ceiling
  ОКРВНИЗ               Floor
  ОКРУГЛ                Round
  ОКРУГЛВВЕРХ           RoundUp
  ОКРУГЛВНИЗ            RoundDown
  ОСНПЛАТ               Ppmt
  ОТРБИНОМРАСП          NegBinomDist
  ОТРЕЗОК               Intercept
  ПДОБ                  Vdb
  ПЕРЕСТ                Permut
  ПЕРСЕНТИЛЬ            Percentile
  ПЕЧСИМВ               Clean
  ПЗ                    Pv
  ПИ                    Pi
  ПИРСОН                Pearson
  ПЛПРОЦ                Ipmt
  ПОВТОР                Rept
  ПОДСТАВИТЬ            Substitute
  ПОИСК                 Search
  ПОИСКБ                SearchB
  ПОИСКПОЗ              Match
  ППЛАТ                 Pmt
  ПРЕДСКАЗ              Forecast
  ПРОИЗВЕД              Product
  ПРОМЕЖУТОЧНЫЕ.ИТОГИ   Subtotal
  ПРОПНАЧ               Proper
  ПРОСМОТР              Lookup
  ПРОЦЕНТРАНГ           PercentRank
  ПУАССОН               Poisson
  РАДИАНЫ               Radians
  РАНГ                  Rank
  РИМСКОЕ               Roman
  РОСТ                  Growth
  РУБЛЬ                 Dollar
  РУБЛЬ                 USDollar
  СЖПРОБЕЛЫ             Trim
  СКОС                  Skew
  СРГЕОМ                GeoMean
  СРГРАМ                HarMean
  СРЗНАЧ                Average
  СРОТКЛ                AveDev
  СТАНДОТКЛОН           StDev
  СТАНДОТКЛОНП          StDevP
  СТЕПЕНЬ               Power
  СТОУШYX               StEyx
  СТЬЮРАСП              TDist
  СТЬЮРАСПОБР           TInv
  СУММ                  Sum
  СУММЕСЛИ              SumIf
  СУММКВ                SumSq
  СУММКВРАЗН            SumXMY2
  СУММПРОИЗВ            SumProduct
  СУММРАЗНКВ            SumX2MY2
  СУММСУММКВ            SumX2PY2
  СЧЁТ                  Count
  СЧЁТЕСЛИ              CountIf
  СЧЁТЗ                 CountA
  СЧИТАТЬПУСТОТЫ        CountBlank
  ТЕКСТ                 Text
  ТЕНДЕНЦИЯ             Trend
  ТРАНСП                Transpose
  ТТЕСТ                 TTest
  УРЕХСРЕДНЕЕ           TrimMean
  ФАКТР                 Fact
  ФИКСИРОВАННЫЙ         Fixed
  ФИШЕР                 Fisher
  ФИШЕРОБР              FisherInv
  ФТЕСТ                 FTest
  ХИ2ОБР                ChiInv
  ХИ2РАСП               ChiDist
  ХИ2ТЕСТ               ChiTest
  ЧАСТОТА               Frequency
  ЧЁТН                  Even
  ЧИСЛОКОМБ             Combin
  ЭКСПРАСП              ExponDist
  ЭКСЦЕСС               Kurt
